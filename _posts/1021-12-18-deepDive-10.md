---
permalink: /Algorithm/deepDive-10
title: "객체 리터럴"
last_modified_at: 2021-12-18T19:21-12:14
categories:
- javascript
tags:
- javascript
---

## 객체 리터럴 ?
➡️ 객체 리터럴에 대해 알기 전에 객체가 뭔지 그리고 인스턴스가 뭔지 개념을 짚고 가보자

- 객체 ? 자바스크립트에서 객체는 프로퍼티와 메서드로 구성된 집합체
- 인스턴스 ? 클래스에 의해 생성되어 메모리에 저장된 실체

** 자바스크립트는 프로토타입 기반 객체지향 언어로 다른 클래스 기반 객체지향 언어와 다르게 생성방법을 지원한다.  
[’객체 리터럴’, ‘Object 생성자 함수’, ‘생성자 함수’, ‘Object.create 메서드’, 클래스(ES6)]

위에서 객체 리터럴 외의 객체 생성 방식은 모두 함수를 사용해 객체를 생성한다.
이번에는 객체 리터럴로 객체를 생성하는 방법에 관하여 살펴보고자 한다.

### ✨ 객체 리터럴 방식

➡️ 중괄호 내에 0개이상의 프로퍼티를 정의하며 변수에 할당되는 시점에 자바스크립트 엔진이 객체 리터럴을 해석하여 객체를 생성한다.

```javascript
let cat = {
  name: 'Meow',
  crying: () => {
    console.log(`${this.name} is crying`)
  }
}; // 객체 리터럴은 값으로 평가되는 표현식이므로 닫는 중괄호 뒤에는 세미콜론을 붙인다.
```

### `프로퍼티 ?`

➡️ 프로퍼티는 key, value 쌍으로 구성되며 객체를 구성한다.  
프로퍼티 키를 선언할때 주의할점이 있다. → 프로퍼티 값에 접근할 수 있는 이름(식별자)로 프로퍼티 키를 선언할 때 식별자 네이밍 규칙을 준수하는 프로퍼티 키와 그렇지 않은 프로퍼티 키의 차이다  
** 가급적 식별자 네이밍 규칙을 준수하는걸 권하지만 만약 프로퍼티 키가 식별자 네이밍 규칙을 따르지 않을시에는 반드시 식별자에 따옴표를 사용해야 한다.

```javascript
let cat= {
  firstName: 'Meow',
  last-name: 'Mang' // Error 
}

// 프로퍼티 키 동적 생성 -> 프로퍼티 키로 사용할 표현식을 대괄호로 묶어야 한다.
cat['age'] = 3

----------------

// var, function과 같은 옝약어를 프로퍼티 키로 사용하는건 권장X - 네이밍에 항상 신경쓰자
// 이미 존재하는 프로퍼티 키를 중복 선언하면 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어쓴다.
```

### `자바스크립트 함수는 객체(일급 객체)다`

➡️ 함수는 값으로써 취급할 수 있기 때문에 프로퍼티 값으로 사용할 수 있다. 따라서 프로퍼티 값이 함수일 경우에는 일반 함수와 구분하기 위해 메서드라 칭한다.

### 프로퍼티 접근 방식
```javascript
1. 마침표 프로퍼티 접근 연산자를 사용하는 마침표 표기법
console.log(cat.name); // Meow
2. 대괄호 프로퍼티 접근 연산자를 사용하는 대괄호 표기법
console.log(cat['name']) // Meow 

// 대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다. (프로퍼티 키가 숫자면 따옴표 생략가능)
// 그렇지 않다면 식별자로 해석하기 때문에 책에서는 undefined을 반환? 그냥 에러 나는데..?
// 네이밍 규칙을 준수하지 않는 이름일 경우에는 대괄호 프로퍼티 접근 연산자로 해야한다!
let person = {
  'last-name' : 'Lee',
  1: 10
}

person.'last-name' // SyntaxError
person.last-name // 브라우저 : NaN

person[last-name]; // ReferenceError
person['last-name'] // Lee

person.1 // SyntaxError
person.'1' // SyntaxError
person[1] // 10
person['1'] // 10
```

** 위의 Node와 브라우저 환경에서 결과가 다른것은 브라우저에서는 전역변수 name이 전역객체 window의 프로퍼티로 암묵적으로 존재하기 때문

### 객체 리터럴 - ES6에서 사용해보자

```javascript
1.프로퍼티 축약 표현

// 프로퍼티 값으로 변수를 사용하는 경우 -> 
// 변수 이름과 프로퍼티 키가 동일한 이름일 때는 프로퍼티 키를 생략할 수 있다!

// ES5
var x = 1, y = 2;
var obj = {
  x: x,
  y: y
}
// ES6
let x = 1, y = 2;

const obj = { x, y };

2. 게산된 프로퍼티 이름

// ES5
// 아래와 같이 ES5에서는 게산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성하기 위해서는 객체 리터럴 외부에서 대괄호 표기법을 사용해야함
var prefix = 'prop';
var i = 0;

var obj = {};

obj[prefix + '-' + ++i] = i;
obj[prefix + '-' + ++i] = i;
obj[prefix + '-' + ++i] = i;
console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}

// ES6
// ES6는 5와 달리 객체 리터럴 내부에서 계산된 프로퍼티 이름으로 바로 프로퍼티 키를 동적 생성 할 수 있다.
const obj = {
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i
}

3. 메서드 축약 표현
// ES5
var obj = {
  sayHi: function() {
    console.log('Hi! ' + this.name);
  }
}

// ES6
// function 키워드를 생략한 축약표현 가능
// 아래와 같이 선언하게 되면 인스턴스를 생성할 수 없게 되므로 생성자 함수로서 호출할 수 없다.
// 위 ES5처럼 메서드가 아닌 일반 함수로 프로퍼티 값을 할당하게 되면 super키워드 사용 불가
const obj = {
  sayHi() {
    console.log('Hi! ' + this.name);
  }
}
```