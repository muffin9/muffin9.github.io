---
permalink: /react/hook
title: "Hook"
categories: React

tags: React Hook useState

toc: true
toc_sticky: true


date: 2022-10-06
last_modified_at: 2022-10-06
---

### `✍🏻 Hook의 개요`

Hook은 React 버전 16.8부터 React 요소로 새로 추가되었다. 이전에는 클래스형 문법으로 작성한 리액트에게 있어서 새롭게 함수형 컴포넌트 기반으로 작성할수 있게 해주는 문법이다.  

Hooks이 나온 배경은 지난 몇년간 클래스형 컴포넌트 기반으로 작성되어진 부분에서 여러 문제들을 좀 더 깔끔하게 해결하기 위해 나온 것.

1. 컴포넌트 사이에서 상태 로직을 재사용하기 어렵다.

2. 복잡한 컴포넌트들은 이해하기 어렵다.

3. 이전 클래스형 문법은 사람과 기계를 혼동시킨다.

### `Hook의 특징`

1. 선택적으로 사용이 가능하다 - 기존의 클래스형 기반 코드를 다시 모두 Hooks로 작성할 필요 없이 일부의 컴포넌트들 안에서 Hook을 사용할 수 있다. (어느정도 구축이된 프로젝트에서 모든 코드를 갈아 엎는건 유지보수가 굉장히 많이 드는데 이런 점을 고려하여 클래스형과 Hooks를 같이 사용해도 된다.)

2. Hook은 알고 있는 React 컨셉을 대체하지 않는다. - Hooks는 기존 React가 가지고 있는 props, state, context, refs, 그리고 lifecycle와 같은 React 개념에 좀 더 직관적인 API를 제공할 뿐

3. 최상위에서만 Hook을 호출해야 한다. - 반복문, 조건문 혹은 중첩된 함수 내에서 Hook을 호출하면 안된다. early return이 되기 전에 항상 React 함수 최상위에서 Hook을 호출해야 컴포넌트가 렌더링이 될 때마다 항상 동일한 순서로 Hook이 호출되는 것을 보장하기 때문. => 이 규칙이 존재하여 차후에 학습할 State와 Effect를 여러개 사용할 수 있게 해준다.

---

### `Hook State`

HOOK API 중 하나인 useState로 해당 컴포넌트 내에서의 상태를 관리할 수가 있다. 여기서 Hook에서 제공하는 API들은 `use`라는 키워드로 시작한다. 그럼 함수형 컴포넌트 기반인 Hook을 사용했을때 `useState`에 대해 파헤쳐보자.

`useState 등장배경 ?`  

🤔 함수 컴포넌트에서 상태관리를 도와주는 이 useState 어떻게하다가 생겨났을까 ?  
`useState`가 의미하는 상태라는 개념자체가 JavaScript 생태계에서의 지역변수와 매우 유사한데, 컴포넌트가 마운트되고 언마운트될 때까지 유지되는 값이다.  
JavaScript 같은경우엔 지역변수의 값이 함수가 반환되는 시점에 메모리에서 사라진다는 점인데 이와달리 리액트에서의 컴포넌트 상태와는 약간 다르다.  

>> React 컴포넌트 내부에서 선언한 지역 변수는 컴포넌트가 렌더링되고 다시 렌더링되기 전까지만 유지된다.  

Hook이 등장하기 전 함수 컴포넌트에서는 상태를 따로 저장하고 유지할 수 없었다.  
그럼 왜 컴포넌트 내부에 선언한 지역 변수 값은 컴포넌트를 렌더링할 때마다 유지되지 않을까?  

React는 컴포넌트 상태가 변경이 되면 기본적으로 해당 컴포넌트부터 모든 자식 컴포넌트까지 render 함수를 실행하고 reconcilation을 수행하게 된다.  

이렇게 지역 변수로는 함수 컴포넌트의 상태를 관리할 수 없기 때문에 등장한 `useState` 어떻게 사용되어지는 살펴보자.

```javascript
import React, { useState } from 'react'; // 상태관리를 위한 Hook API useState 임포트

const CountExample = () => {
   const [count, setCount] = useState(0); // count state 0으로 초기화, count를 변경하고 싶으면 setCount 함수 사용

   // 아래 3줄이 위 1줄과 같다.
   // const countState = useState(0);
   // const count = countState[0];
   // const setCount = countState[1];

   return (
    <div>
        <p>You clicked {count} times</p>
         <button onClick={() => setCount(count + 1)}> 
         Click me
        </button>
    </div>
    );
  }
```

예제는 간단히 React 공식문서에서 설명하는 예제를 가져왔다. 보통 컴포넌트 이름은 맨 앞의 문자는 대문자로 시작하여 카멜케이스 기법을 사용한다.

`useState의 인자 ?` Hook의 인자로 넘겨주는 값은 state(count)의 초기값인데, 위 예에서는 0이라는 값을 초기값으로 설정했다. 올 수 있는 값으로는 객체, 배열, 숫자, 문자타입 등 여러가지가 가능하다.  

**초기 상태값은 컴포넌트 마운트 시에만 상태에 반영되고 컴포넌트를 업데이트 할 땐 무시**

`useState의 반환값은 정확히 뭘까 ?` state의 변수 / state 변수를 갱신할 수 있도록 하는 setState함수를 쌍으로 반환하게 된다. 여기서 반환받을때 `배열 구조 분해` 로 깔끔하게 한 번에 받도록 하였다. state를 변경하고 싶으면 setState함수로 변경해야 리렌더링이 발생.  

`⚠️ 만약 setState 함수로 state를 변경하지 않고 state에 직접적으로 접근해서 변경한다면 ? `

```javascript
import { useState } from "react";

export default function App() {
  const [info, setInfo] = useState({ name: "muffin", gender: "male" });
  let [count, setCount] = useState(0);

  const handleOnClick = () => {
    count = 1;
    info.name = "updatedMuffin";
  };

  return (
    <div>
      <button onClick={handleOnClick}>Button Clicked</button>
      <p>Count : {count}</p>
      <p>name: {info.name}</p>
    </div>
  );
}

```

![짤](https://user-images.githubusercontent.com/45479309/194231429-ca157d89-215a-4079-b6cf-8d84a15c9c8c.png)

![state 직접 변경](https://user-images.githubusercontent.com/45479309/194231492-3d7a918b-132c-4d91-81ad-bb76814d6206.png)

버튼을 클릭하면 아무일도 일어나지 않는다.

---

>> handleOnClick 함수 내에서 setter 함수로 state값을 변경해보자.

```javascript
  const handleOnClick = () => {
    setCount(count + 1);
    setInfo({ ...info, name: "updatedMuffin" });
  };
```

![setter 함수 사용 gif](https://user-images.githubusercontent.com/45479309/194231507-85dd5761-572a-43b0-b095-fc44017b8c46.gif)

setter 함수로 state를 변경해야 비로소 해당 App 컴포넌트가 리렌더링이 발생한다.

`⚠️ setState를 함수를 호출하면 state를 변경하지만, 이 setState를 호출한다고 해서 상태가 바로 변경되지는 않는다!`

위와 같이 바로 변경되지 않는 이유는, setState 함수는 상태 변경을 비동기로 수행하기 때문인데 상태 업데이트를 나중으로 예약하고 현재 JavaScript 호출 스택이 전부 비워지면 그때 실제로 상태를 변경한다.  

추가적으로, 기존상태와 새로운 상태 변화가 없다면? 내부적으로 `Object.is` 메서드를 사용하여 이전 상태와 같다고 판단되면 render 함수 실행과 reconcilation을 수행하지 않는다.  

**Object.is()가 ===의 가장 큰 차이는 Object.is()는 NaN 비교와 +0, -0 비교가 가능해졌다는 점**

