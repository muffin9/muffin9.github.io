---
permalink: /boj/N과 M(1)
title: "N과 M(1)"
categories: BOJ
tags: 재귀

toc: true
toc_sticky: true

date: 2022-10-03
last_modified_at: 2020-10-03
---

## N과 M(1)

https://www.acmicpc.net/problem/2003

### 문제

![image](https://user-images.githubusercontent.com/45479309/193596019-97c4e858-ee97-41a1-946a-c89d0cfc1296.png)

```javascript
const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split("\n");

const solution = () => {
    const [N, M] = input.shift().split(" ").map(v => +v);
    const arr = []
    const visited = new Array(N).fill(false);
    let answer = '';

    const recur = (idx) => {
        if(idx === M) {
            answer += `${arr.join(" ")}\n`;
            return;
        }

        for(let i = 0; i < N; i++) {
            if(visited[i]) continue;
            visited[i] = true;
            arr.push(i + 1);
            recur(idx + 1);
            arr.pop();
            visited[i] = false;
        }
    }

    recur(0);
    console.log(answer.trim());
}

solution();
```

재귀에 익숙해지기 위해 이전에 풀어본 N과 M 시리즈를 다시 풀어보고 있다.  

같은 수를 한 번더 쓸 수 없기에 visited 배열을 두어 해당 요소를 방문했는지 체크 해주었고, 재귀를 돌때마다 idx가 1씩 증가시키면서 M과 같아질때 answer에 계속 축적해주는 이유는 console.log를 계속 찍는걸 피하기 위해서 answer 변수를 사용해 주었음.  

arr배열에 요소를 push하고 재귀함수를 호출후 다시 pop을 해줘야 0부터 N까지 요소를 번갈아 탐색할 수가 있다.