---
permalink: /boj/적록색약
title: "적록색약"
categories: BOJ
tags: BFS

toc: true
toc_sticky: true

date: 2020-10-20
last_modified_at: 2020-10-20
---

## 적록색약

[적록색약 풀러가기](https://www.acmicpc.net/problem/10026)

### 문제

<img width="1161" alt="적록색약" src="https://user-images.githubusercontent.com/45479309/197001059-46b964f2-0591-4755-b1b6-0afff9eeb1b8.png">


### 내풀이

```javascript
const [value, ...input] = require('fs').readFileSync('10026.txt').toString().trim().split("\n");

const solution = () => {
    const N = +value;
    const map = new Array(N);
    let visited = Array.from(new Array(N), () => new Array(N).fill(false));
    const moveX = [-1, 1, 0, 0];
    const moveY = [0, 0, -1, 1];

    for(let i = 0; i < N; i++) {
        map[i] = input[i].split("");
    }

    const bfs = (x, y) => {
        const queue = [[x, y]];

        while(queue.length) {
            const [x, y] = queue.shift();
            visited[x][y] = true;
            const currentColor = map[x][y];

            for(let i = 0; i < 4; i++) {
                const nextX = x + moveX[i];
                const nextY = y + moveY[i];
                if(nextX < 0 || nextX >= N || nextY < 0 || nextY >= N) continue;
                if(visited[nextX][nextY]) continue;

                if(map[nextX][nextY] === currentColor) {
                    visited[nextX][nextY] = true;
                    queue.push([nextX, nextY]);
                }
            }
        }
    }

    let blindNessCount = 0;
    let notBlindNessCount = 0;


    // 적록색약 아닌 사람.
    for (let i = 0; i < N; i++) {
        for (let j = 0; j < N; j++) {
          if (!visited[i][j]) {
            bfs(i, j);
            notBlindNessCount++;
          }
        }
    }

    // 적록색약 일 때
    for(let i = 0; i < N; i++) {
        map[i] = input[i].split("");
    }
    // 색 Change
    for (let i = 0; i < N; i++) {
        for (let j = 0; j < N; j++) {
          if (map[i][j] === "G") map[i][j] = "R";
        }
      }
    visited = Array.from(new Array(N), () => new Array(N).fill(false));
    for (let i = 0; i < N; i++) {
        for (let j = 0; j < N; j++) {
          if (!visited[i][j]) {
            bfs(i, j);
            blindNessCount++;
          }
        }
    }
    console.log(notBlindNessCount, blindNessCount);
}

solution();
```

적록색약인 사람이 볼때의 카운팅(blindNessCount) / 적록색약이 아닌 사람이 볼때의 카운팅(notBlindNessCount) 개수를 따로 구하도록 하였다.  

map과 visited 배열도 먼저 적록색약이 아닌사람일때의 BFS 알고리즘을 순회한 후 map, visited를 적록색약인 사람일때도 다시 순회시켜주기 위해 map을 초기화 해줌과 동시에 G 색상을 R로 변경하여 셋팅.  

visited 배열도 전부 False로 초기화시킴으로써 두 BFS를 순회한 값을 구해내면 되었다.  

BFS는 기존의 방식에서 크게 벗어나지않게 사용하여 어렵지 않게 풀 수 있었다.