---
permalink: /boj/연결요소의 개수
title: "연결요소의 개수"
categories: BOJ
tags: BFS

toc: true
toc_sticky: true

date: 2020-10-20
last_modified_at: 2020-10-20
---

## 연결요소의 개수

[연결요소의 개수 풀러가기](https://www.acmicpc.net/problem/11724)

### 문제


<img width="1169" alt="연결요소의개수" src="https://user-images.githubusercontent.com/45479309/197000695-4a892317-f795-4fa0-8fec-f8df1346188f.png">

### 내풀이

```javascript
const fs = require('fs');
const [values, ...input] = fs.readFileSync('11724.txt').toString().trim().split("\n");

const solution = () => {
    const [N, M] = values.split(" ").map(v => +v);
    const map = Array.from(new Array(N + 1), () => []);
    const visited = new Array(N + 1).fill(false);
    let answer = 0;

    for(let i = 0; i < input.length; i++) {
        const [v1, v2] = input[i].split(" ").map(v => +v);
        map[v1].push(v2);
        map[v2].push(v1);
    }   
    
    const bfs = (node) => {
        const queue = [node];

        while(queue.length) {
            const currentNode = queue.shift();
            if(!map[currentNode]) break;
            for(let i = 0; i < map[currentNode].length; i++) {
                const nextNode = map[currentNode][i];
                if(!visited[nextNode]) {
                    visited[nextNode] = true;
                    queue.push(nextNode);
                }
            }
        }
    }

    for(let i = 1; i <= N; i++) {
        if(!visited[i]) {
            answer += 1;
            bfs(i);
        }
    }
    console.log(answer);
}

solution();
```

visited 배열로 1번 노드부터 N번 노드까지 순차적으로 BFS 탐색하면 되는데, 탐색되지 않은 노드일때 => 해당 노드 부터는 다시 탐색을 해야 한다. 이 때 다시 탐색해야 하는 노드이기 때문에 연결 요소의 개수를 하나 추가해주면 된다.