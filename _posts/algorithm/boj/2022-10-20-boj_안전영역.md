---
permalink: /boj/안전영역
title: "안전영역"
categories: BOJ
tags: BFS

toc: true
toc_sticky: true

date: 2020-10-20
last_modified_at: 2020-10-20
---

## 안전영역

[안전영역 풀러가기](https://www.acmicpc.net/problem/2468)

### 문제

<img width="1199" alt="안전영역1" src="https://user-images.githubusercontent.com/45479309/197001447-96a94c99-d52f-4b6b-9ad3-5deb5abf7c9a.png">

<img width="1149" alt="안전영역2" src="https://user-images.githubusercontent.com/45479309/197001458-40907509-cd65-4b3c-bd77-1898fe5e5d6d.png">

### 내풀이

```javascript
const [value, ...input] = require('fs').readFileSync('2468.txt').toString().trim().split("\n");


const solution = () => {
    const N = +value;
    const map = Array.from(new Array(N), () => []);
    const moveX = [-1, 1, 0, 0];
    const moveY = [0, 0, -1, 1];
    let answer = 0;
    for(let i = 0; i < N; i++) {
        map[i] = input[i].split(" ").map(v => +v);
    }

    const sinkMap = (visited, num) => {
        for(let i = 0; i < N; i++) {
            for(let j = 0; j < N; j++) {
                if(map[i][j] <= num) visited[i][j] = true;
            }
        }
    }

    const bfs = (visited, x, y) => {
        const queue = [[x, y]];

        while(queue.length) {
            const [x, y] = queue.shift();
            visited[x][y] = true;

            for(let i = 0; i < 4; i++) {
                const nextX = x + moveX[i];
                const nextY = y + moveY[i];
                if(nextX < 0 || nextX >= N || nextY < 0 || nextY >= N) continue;
                if(!visited[nextX][nextY]) {
                    visited[nextX][nextY] = true;
                    queue.push([nextX, nextY]);
                }
            }
        }
    }

    for(let i = 0; i <= 100; i++) {
        const visited = Array.from(new Array(N), () => new Array(N).fill(false));
        let count = 0;
        sinkMap(visited, i);
        for(let j = 0; j < N; j++) {
            for(let k = 0; k < N; k++) {
               // visited BFS. 
               if(!visited[j][k]) {
                visited[j][k] = true;
                bfs(visited, j, k);
                count += 1;
                }
            }
        }
        answer = Math.max(answer, count);
    }
    console.log(answer);
}

solution();
```

높이 0 ~ 100 까지 BFS로 계속 탐색해주면서 그 중 가장 최대값을 리턴하면 되는 문제다.  

100번 BFS 탐색을해주면서 방문했던 배열 visited를 초기화를 해주면서 sinkMap함수로 i(0 ~ 100) 의 수를 계속 순회하면서 해당 i보다 작은 값들을 모두 물에 잠긴 영역으로 표시(visited의 해당 요소 true) 순회 이후 인접한 영역을 포함한 물에 잠기지 않는 영역이 얼마나 되는지 bfs로 순회하면서 count값을 얻어내었다.  

bfs 함수를 사용하는건 다른 문제와 유사해서, sinkMap함수를 통해 물에 잠기는 영역을 계속 체크해야 하는걸 생각하는게 중요했던 문제.