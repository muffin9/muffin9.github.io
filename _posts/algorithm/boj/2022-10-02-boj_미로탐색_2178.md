---
permalink: /boj/미로탐색
title: "미로탐색"
categories: BOJ
tags: BFS

toc: true
toc_sticky: true

date: 2022-10-02
last_modified_at: 2020-10-02
---

## 미로탐색

https://www.acmicpc.net/problem/2178

### 문제

![image](https://user-images.githubusercontent.com/45479309/193461392-869f0837-ed46-4d68-90ed-ec9ea57261e7.png)

```javascript
const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split("\n");

const solution = () => {
    const [N, M] = input.shift().split(" ").map(v => +v);
    const map = Array.from(new Array(N), () => new Array(M).fill(0));
    const visited = Array.from(new Array(N), () => new Array(M).fill(0));
    const moveX = [-1, 1, 0, 0];
    const moveY = [0, 0, -1, 1];

    for(let i = 0; i < N; i++) {
        map[i] = input[i].split("").map(v => +v)
    }

    const BFS = (y, x) => {
        const queue = [{ x, y }];
        visited[y][x] = 1;

        while(queue.length) {
            const { y, x } = queue.shift();
            
            for(let i = 0; i < 4; i++) {
                const nextX = x + moveX[i];
                const nextY = y + moveY[i];

                if(nextX >= 0 && nextX < M && nextY >= 0 && nextY < N) {
                    if(!visited[nextY][nextX] && map[nextY][nextX]) {
                        visited[nextY][nextX] = visited[y][x] + 1;
                        queue.push({ y: nextY, x: nextX });
                    }
                }
            }
        }
    }

    BFS(0, 0);
    console.log(visited);
}

solution();
```

> **최단 거리를 구하는 문제는 거의 대부분 bfs 문제.**

다음 좌표를 계산할때는 동, 서, 남, 북을 기준으로 움직일 수 있는데, 주어진 좌표중에서 이동할 수 있는 값을 의미하는 1의 좌표를 가질때의 거리를 ⇒ 계속 이전 지점까지의 거리를 누적을 해서 계산 해주면 된다.

기존 BFS 문제와 유사하게 visited라는 변수를 활용하여 마지막 칸까지 가는데 필요한 최소 이동거리를 누적.

**동 : (0, 1)**

**서 : (0, -1)**

**남 : (1, 0)**

**북 : (-1, 0)**

주어진 Map의 칸을 처음 방문한 경우 OR 더 짧게 갈 수 있는 방법을 찾은 경우, 

해당 칸에서 상하좌우를 체킹하여 더 짧은 경로를 만들 수 있는 칸을 찾는다. 

만약 주변에 경로가 짧아지는 칸이 있다면, 짧은 이동거리로 갱신하고 ⇒ 큐에 담아 해당 칸 주변을 반복해서 검사