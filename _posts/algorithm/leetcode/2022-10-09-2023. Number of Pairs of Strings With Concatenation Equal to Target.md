---
permalink: /leetcode/Number of Pairs of Strings With Concatenation Equal to Target
title: "Number of Pairs of Strings With Concatenation Equal to Target"
categories: Leetcode
tags: Bruteforce

toc: true
toc_sticky: true


date: 2022-10-10
last_modified_at: 2020-10-10
---

## Number of Pairs of Strings With Concatenation Equal to Target

[Number of Pairs of Strings With Concatenation Equal to Target 풀기](https://leetcode.com/problems/number-of-pairs-of-strings-with-concatenation-equal-to-target/)

### 문제

<img width="1256" alt="Number of Pairs of Strings With Concatenation Equal to Target" src="https://user-images.githubusercontent.com/45479309/194839475-31bf038f-0f03-47b1-ae1e-803351441144.png">


### 내풀이

```javascript
/**
 * @param {string[]} nums
 * @param {string} target
 * @return {number}
 */
var numOfPairs = function(nums, target) {
    let count = 0;
    for(let i = 0; i < nums.length; i++) {
        const str1 = nums[i];
        const len1 = str1.length;
        for(let j = 0; j < nums.length; j++) {
            if(i === j) continue;
            let str2 = nums[j];
            const len2 = str2.length;

            if(str1 + str2 === target) {
                count += 1;
            }
        }
    }
    return count;
};
```

주어진 nums 배열을 이중 반복문을 사용한 완전탐색으로 해결하였다.  
이중 for 문 내에서의 조건처리에서 str1 값과 str2의 합친 문자가 target 값과 일치할때 count 1 값 증가 시키기.  


---

### 시간복잡도 O(n)의 풀이

```javascript
var numOfPairs = function(nums, target) {
    let map = {}
    let count = 0;
  
    for(const num of nums){
        if(map[num]) map[num]++
        else map[num] = 1
    }

    for(let num of nums){
        const str = target.substring(num.length)
        map[num]--
        if(target.startsWith(num) && map[str]) count += map[str]
        map[num]++
    }
    return count 
};
```

다른 사람의 풀이를 살펴보며 객체를 이용하여 시간복잡도 O(n)으로도 해결할 수 있었다.  

객체에 문자를 키로하고 해당 문자의 빈도수를 value으로 하여 해결한게 굉장히 인상적이었다.  

