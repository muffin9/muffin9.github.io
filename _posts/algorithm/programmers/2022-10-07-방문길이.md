---
permalink: /programmers/방문길이
title: "방문길이"
categories: Programmers
tags: Bruteforce

toc: true
toc_sticky: true

date: 2020-10-07
last_modified_at: 2020-10-07
---

## 방문길이

https://school.programmers.co.kr/learn/courses/30/lessons/49994

### 문제

<img width="986" alt="방문길이1" src="https://user-images.githubusercontent.com/45479309/194520835-fee4c338-f6a8-49ed-83d4-f1e8aa3edc9c.png">
<img width="991" alt="방문길이2" src="https://user-images.githubusercontent.com/45479309/194520829-dc29817f-7f43-43c3-88e0-9316dde3a8ff.png">
<img width="971" alt="방문길이3" src="https://user-images.githubusercontent.com/45479309/194520826-2162c488-096c-4892-a2f7-60f5581db29b.png">


### 1차 풀이

```javascript
function solution(dirs) {
    // 중앙 값을 (5, 5)로 두고 주어진 dirs 만큼 움직이자.
    // 0 ~ 10 내의 범위를 초과하는 값들은 if문으로 처리
    // 모두 이동 후에 count 값 리턴.
    const move = {'U': [0, 1], 'D': [0, -1], 'R': [1, 0], 'L': [-1 ,0]};
    let currentPositionrentPosition = [0, 0];
    const visited = []; // 방문한 좌표 목록
    let count = 0;

    for(let i = 0; i < dirs.length; i++) {
        const position = dirs[i];
        const currentPositionrentX = currentPositionrentPosition[0] + move[position][0];
        const currentPositionrentY = currentPositionrentPosition[1] + move[position][1];
        if(currentPositionrentX > 5 || currentPositionrentX < -5 || currentPositionrentY > 5 || currentPositionrentY < -5) continue;

        currentPositionrentPosition = [currentPositionrentX, currentPositionrentY];

        const isVisited = visited.find((coords) => {
            if((coords[0] === currentPositionrentX && coords[1] === currentPositionrentY) || (coords[0] === currentPositionrentY && coords[1] === currentPositionrentX)) return true;
            return false;
        });

        if(!isVisited) {
            count += 1;
            visited.push([currentPositionrentX, currentPositionrentY]);
        }
    }

    return count;
}
```

막연하게 방문한 좌표 개수를 담으면 될 줄 알았는데 그게 가는좌표와 오는좌표도 생각하여 방문한 길이를 구해야했다.


---

### 2차 풀이

```javascript
function solution(dirs) {
    const move = {'U': [0, 1], 'D': [0, -1], 'R': [1, 0], 'L': [-1 ,0]};
    let currentPosition = [0, 0];
    const visited = new Set();

    for (const dir of dirs) {
        const nextX = currentPosition[0] + move[dir][0];
        const nextY = currentPosition[1] + move[dir][1];
        
        if (nextX > 5 || nextX < -5 || nextY > 5 || nextY < -5) continue;
        
        visited.add(`${currentPosition[0]}${currentPosition[1]}${nextX}${nextY}`);
        visited.add(`${nextX}${nextY}${currentPosition[0]}${currentPosition[1]}`);
        
        currentPosition = [nextX, nextY];
    }

    return visited.size / 2;
}
```

시작좌표와 도착한 좌표 모두 저장하기 위함과 동시에 중복이 아닌 방문했던 좌표 자체를 담기 위해 visited 변수를 Set 객체로 선언하였다.  

주어진 명령어 U,D,R,L는 미리 객체형태로 key에는 주어진 입력값 중 하나, value는 그에 대응하는 좌표 이동 x,y를 미리 심어주었다.  

시작 좌표는 0,0이므로 currentPosition 변수로 제어 하였으며 이동한 x, y 좌표가 범위 밖인지 체킹을 해주고, visited에는 시작점좌표와 이동된 좌표 2개를 넣어주고, currentPosition 값은 이동된 좌표로 업데이팅 시켜주었다.  

이 문제에 핵심은 같은 길로 되돌아오는 경우를 생각하는 로직인데, 해당 로직은 처음 풀이와 달리 순서를 뒤바꿔서 각각 2번 넣어줌으로써 해결하였다. 

⇒ 반대방향으로 거쳐간 거리도 넣어줘야 길이를 구할 수 있기 때문이다. (0,0) -> (0,1) 과 (0,1) ⇒ (0,0) 은 같은 길이기 때문.