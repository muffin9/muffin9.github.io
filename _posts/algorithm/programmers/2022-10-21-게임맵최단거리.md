---
permalink: /programmers/게임맵최단거리
title: "게임맵최단거리"
categories: Programmers
tags: BFS

toc: true
toc_sticky: true

date: 2020-10-21
last_modified_at: 2020-10-21
---

## 게임맵최단거리

[게임맵최단거리 풀러가기](https://school.programmers.co.kr/learn/courses/30/lessons/49994)

### 문제

<img width="991" alt="게임맵최단거리1" src="https://user-images.githubusercontent.com/45479309/196999724-84f1a1ed-c776-46b1-8657-64d3f8de4c17.png">

<img width="977" alt="게임맵최단거리2" src="https://user-images.githubusercontent.com/45479309/196999758-0b48398b-cd21-4725-908e-c7a389526806.png">


### 내풀이

```javascript
function solution(maps) {
    const n = maps.length;
    const m = maps[0].length;
    const visited = Array.from({length: n}, () => new Array(m).fill(0));

    const moveX = [-1, 1, 0, 0];
    const moveY = [0, 0, -1, 1];

    const checkBlock = (x, y) => {
        if(x >= 0 && x < n && y >= 0 && y < m) return true;
        return false;
    }

    const bfs = (x, y) => {
        const queue = [{x, y}];
        visited[x][y] = true;

        while(queue.length) {
            const {x, y} = queue.shift();

            for(let i = 0; i < 4; i++) {
                const nextX = x + moveX[i];
                const nextY = y + moveY[i];

                if(!checkBlock(nextX, nextY)) continue;

                if(!visited[nextX][nextY] && maps[nextX][nextY]) {
                    visited[nextX][nextY] = visited[x][y] + 1;
                    queue.push({x: nextX, y: nextY});
                }
            }
        }
    }

    bfs(0, 0);
    if(visited[n - 1][m - 1] === 0) return -1;
    return visited[n - 1][m - 1];
}   
```

최단거리를 구해야하는 문제이므로 BFS 탐색을 이용하여 구현하였다.

탐색하려고 하는 범위만 확인해야하는데, queue를 이용한 BFS 알고리즘으로 좌표 (0, 0)을 시작으로 (n, m) 까지 상하좌우로 갈 수 있는지 체킹하며 visited 배열에 각 좌표마다 최단경로를 계속 저장시키면서 해결하였다.  

visited 마지막 값이 0이라는건 주변이 모두 벽이여서 탐색을 못하기 때문에 -1을 리턴하고 그게아니라면 마지막에 저장된 값을 리턴해주면 최단 경로를 얻어낼수가 있다.