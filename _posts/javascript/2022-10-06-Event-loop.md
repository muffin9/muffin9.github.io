---
permalink: /javascript/eventloop
title: "EventLoop"
categories: Javascript

tags: JavaScript EventLoop

toc: true
toc_sticky: true


date: 2022-10-06
last_modified_at: 2022-10-06
---



### ✍🏻 `이벤트 루프`

자바스크립트에서의 `이벤트 루프` 개념을 다시 되짚어보고자 관련된 내용들을 정리하였다.  

이벤트 루프를 깊게 알아보기 전에 우리가 알아야 할 것이 있는데, 바로 자바스크립트의 큰 특징 중 하나가 `싱글 스레드` 기반으로 동작한다는 것이다.  

이벤트 루프를 잘 몰랐을 때는 어떻게 HTML에 동적으로 여러 기능들이 동시에 처리되는 걸까? 생각했지만 브라우저 환경에서 돌아가는 바로 이 이벤트 루프라는 녀석 때문에 여러 가지 일을 동시에 하는 것처럼 보이는 것이다! 실제로는, 오직 한 번에 하나의 작업만 수행하는 바보 같은 녀석.  

### 🚗 `동작 방식`

그럼 여러 브라우저 환경에서 동시에 처리되는 것처럼 보이는 이 신기한 상황을 한 번 자세하게 살펴보자.  

![동작방식 image](https://user-images.githubusercontent.com/45479309/194205672-8dbc1957-fbd8-446f-b31e-f34864733876.png)

기본적인 동작원리를 그림으로 표현하면 위와 같다.  

함수를 동기적으로 호출하게 된다면? 위 Call Stack 영역에 stack처럼 차곡차곡 쌓이게 된다.

하지만 비동기 통신 요청인 Ajax, 비동기 타이머 함수를 호출하게 된다면 ? 이전에 동기적으로 처리한 것처럼 Call Stack 에서 계속 관리하는 게 아닌 Call Stack -> Web API로 보내버리고 이후 내가 설정한 시간이나 이벤트가 발생한 순간에 순차적으로 태스크 큐에 보내게 된다.  

여기서, 태스크 큐에서 계속 대기 중인 비동기 함수들은 동기적으로 차곡차곡 실행되고 있는 Call Stack이 비워져야 비로소 그때! 태스크 큐 => Call Stack으로 옮겨져 실행하게 된다.  

이렇게 자바스크립트 엔진에서 Call Stack은 단 하나의 Call Stack을 사용하기 때문에 최상위 실행 컨텍스트가 종료되어 Call Stack이 비워지기 전까지는 태스크 큐에서 대기 중인 녀석들은 계속 대기만 하고 있는 상태인 것이다.  

### 🥞 `Call Stack`  

Call Stack은 실행 컨텍스트 스택이라고도 할 수 있는데, 스코프 체인 및 this 관리 / 코드 실행 순서 관리 등을 수행한다. 코드와 그림을 통해 Call Stack이 어떻게 동작하는지 살펴보자.

```javascript
function multiply(x, y) {
    return x * y;
}
function printSquare(x) {
    var s = multiply(x, x);
    console.log(s);
}
printSquare(5);
```

위 코드를 실행시켰을때 Call Stack에 쌓이는 순서는 아래 그림과 같다.

![call stack image](https://user-images.githubusercontent.com/45479309/194206027-297e4a70-3ba5-43a6-91ac-7a0143b3bb49.png)

함수를 실행하게 되면 함수 호출이 콜 스택에 순차적으로 쌓이고 스택의 맨 위에서부터 차례대로 한 번에 하나의 함수만 처리할 수 있다.  

간단하게 예를 들어보자. 만약 여러 사람이 음식을 받기 위해 줄을 서있다고 가정했을 때 앞사람이 음식을 받기 전에는 새치기를 하지 않는 이상 앞사람을 기다려야 하는데 만약 음식이 다 떨어진다면? 음식이 올 때까지 기다려야 하는 상황이 발생한다. 

이렇게 어떤 작업이 실행되어 동작하고 있는 동안에는 브라우저가 다른 일들을 할 수 없다.  

이제 사용자 입장에서 쇼핑몰을 이용한다고 했을 때 장바구니에 있는 물품들을 결제를 했다. 그런데 결제가 완료될 때까지 로딩 스피너가 계속 돌아간다면? 해당 페이지가 다시 리로드가 될 때까지 계속 하염없이 기다려야 한다. 브라우저가 이렇게 `blocking현상`이 많아지게 된다면 사용자 입장에서는 사용하기 불편한 서비스가 될 것임에 분명하다.

하지만, 한 가지 일만 하지 못하는 자바스크립트에게 날개를 달아준 건 바로 브라우저가 많은 `Web API`를 제공하여 비동기 작업을 가능하게 해주기 때문이다.

### `Heap`  

힙은 객체가 저장되는 메모리 공간으로 변수 선언, 함수 저장, 함수 호출 등 작업들이 일어나는 곳이다. Call Stack 요소인 실행 컨텍스트는 힙에 저장된 원시 값과 객체 주소를 참조한다.

![memory heap image](https://user-images.githubusercontent.com/45479309/194204941-ccb7dadd-02f2-4fe2-8e24-4b5c89698ae6.png)

JS는 마크 앤 스윕 알고리즘을 사용하는데, 루트 객체에서 도달할 수 있는지 감지하는 걸 기반으로 한다. 브라우저의 루트는 window 객체이고 NodeJS에서는 global인데, 여기서 `도달할 수 없는 개체`를 쓰레기로 표시하고 나중에 청소한다. (루트 객체는 수집되 않음)



### `task queue` || `event queue` || `callback queue`

이 태스크큐의 용어는 사람마다 부르는 용어가 다른데 모두 같은 영역을 의미하는 것이니 헷갈리지 말자. 태스크 큐는 비동기 함수의 콜백 함수 Or 이벤트 핸들러가 일시적으로 보관되는 영역이다. 태스크 큐보다 우선순위가 더 빠른 마이크로 태스크 큐도 존재한다. (마이크로 태스크 큐는 프로미스 후속 처리 메서드의 콜백 함수가 일시적으로 보관되는 영역)

### `Web API`

웹 브라우저에서 제공하는 기능들을 일컫는데, 브라우저에서 개발자 도구를 열어 `window`를 찍어보면 굉장히 많은 기능들이 존재한다. 이 여러 API 기능들이 백그라운드에서 비동기적으로 작업을 처리할 수 있도록 도와준다.

### 🏃🏻 `코드로 이해하는 Event Loop`

어느 정도 여러 개념들을 살펴봤으니 코드를 통해서 이벤트 루프를 파헤쳐 보자. 예제는 Javascript Deep Dive 책에 수록된 예제를 가져왔다.

```javascript
function foo() {
    console.log('foo');
}
function foo() {
    console.log('bar');
}

setTimeout(foo, 0);
bar();
```

1. 전역 코드 평가 => 전역 실행 컨텍스트 생성되며 이 실행 컨텍스트가 Call Stack에 푸시

2. 위에서 순차적으로 코드가 읽혀지며 setTimeout 함수가 호출되어 setTimeout 함수 실행 컨텍스트가 생성 => Call Stack에 푸시, 브라우저 Web API인 타이머 함수도 함수 실행 컨텍스트 생성

3-1. `브라우저 수행 처리` : 브라우저는 타이머를 설정하고 타이머 만료를 기다린다. 타이머가 만료되면 콜백 함수 foo가 태스크 큐에 푸시. Call Stack이 비워질 때까지 태스크 큐에 적재되어 있는 상태

3-2. `자바스크립트 엔진 수행 처리` : bar 함수가 호출되어 bar 함수 실행 컨텍스트가 생성되고 콜 스택에 푸시, 이후 bar 함수가 종료되어 콜 스택에 팝 된다. (이 시점에 foo 함수는 아직 태스크 큐에 대기 중)

4. 전역 코드 실행이 종료가 되며 전역 실행 컨텍스트가 콜 스택에 팝, 콜 스택에는 이제 아무것도 존재하지 않는다.

5. 이벤트 루프가 계속 감지하면서 콜 스택이 이제 비어있음을 알고 태스크 큐에서 대기 중인 Call Stack 함수 foo가 이벤트 루프에 의하여 콜 스택에 푸시, 콜백 함수 foo의 함수 실행 컨텍스트가 생성되고 콜 스택에 푸시

6. foo 함수가 종료가 되어 Call Stack에서 팝.

---

### 🖱 `MouseMove event`

마우스를 이동할때마다 발생하는 이벤트리스너 함수인 mousemove를 만들었다.  

![mousemove image](https://user-images.githubusercontent.com/45479309/194205647-fa19b762-6e29-4def-8015-eb0c23be0be3.png)

이동할 때마다 발생하기 때문에, 콜백 함수 내에 만약 여러 가지 로직이 동작된다고 가정한다면 자칫하다가는 성능적인 이슈가 발생할 수 있다. 이런 비동기 함수를 계속적으로 발생하는 걸 막기 위해 `디바운싱이나 쓰로틀링` 같은 기법을 사용할 수 있다.


### ⭐️ 기억하고 넘어가자

**싱글 스레드 방식으로 동작하는 것은 브라우저가 아닌 브라우저에 내장된 자바스크립트 엔진이다. 자바스크립트는 싱글스레드지만 브라우저는 멀티 스레드다.**

`참고 출처`

https://im-developer.tistory.com/113

https://felixgerschau.com/javascript-memory-management/